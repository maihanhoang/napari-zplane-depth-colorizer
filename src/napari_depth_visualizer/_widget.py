"""
This module contains four napari widgets declared in
different ways:

- a pure Python function flagged with `autogenerate: true`
    in the plugin manifest. Type annotations are used by
    magicgui to generate widgets for each parameter. Best
    suited for simple processing tasks - usually taking
    in and/or returning a layer.
- a `magic_factory` decorated function. The `magic_factory`
    decorator allows us to customize aspects of the resulting
    GUI, including the widgets associated with each parameter.
    Best used when you have a very simple processing task,
    but want some control over the autogenerated widgets. If you
    find yourself needing to define lots of nested functions to achieve
    your functionality, maybe look at the `Container` widget!
- a `magicgui.widgets.Container` subclass. This provides lots
    of flexibility and customization options while still supporting
    `magicgui` widgets and convenience methods for creating widgets
    from type annotations. If you want to customize your widgets and
    connect callbacks, this is the best widget option for you.
- a `QWidget` subclass. This provides maximal flexibility but requires
    full specification of widget layouts, callbacks, events, etc.

References:
- Widget specification: https://napari.org/stable/plugins/guides.html?#widgets
- magicgui docs: https://pyapp-kit.github.io/magicgui/

Replace code below according to your needs.
"""
from typing import TYPE_CHECKING

from magicgui import magic_factory
from magicgui.widgets import CheckBox, Container, create_widget
from qtpy.QtWidgets import QHBoxLayout, QPushButton, QWidget
from skimage.util import img_as_float
from skimage.color import rgb2gray
import numpy as np
from napari.utils.notifications import show_info
import math
from qtpy.QtWidgets import QWidget, QHBoxLayout, QVBoxLayout, QLabel, QComboBox, QLineEdit, QGridLayout, QSpinBox, QSlider
from PyQt5.QtCore import Qt
import napari
from superqt import QLabeledDoubleRangeSlider

#----------------------------------------------------------------------------------------------------
class ExampleQWidget(QWidget):
    def __init__(self, napari_viewer):
        super().__init__()
        self.viewer = napari_viewer

        ### Define widgets ###
        # Input
        self._input_layer = QComboBox()
        self._update_input_options()

        # Shift by
        self._shift_1 = QSpinBox(minimum=-10, maximum=+10, value=-1)
        self._shift_2 = QSpinBox(minimum=-10, maximum=+10, value=0)
        self._shift_3 = QSpinBox(minimum=-10, maximum=+10, value=+1)

        # Projection types
        proj_type_options = ['Raw', 'Average Intensity', 'Min Intensity', 'Max Intensity',
                            'Sum Slices', 'Standard Deviation', 'Median']
        self._projection_types_1 = QComboBox()
        self._projection_types_1.addItems(proj_type_options)
        self._projection_types_1.setCurrentText("Average Intensity")
        
        self._projection_types_2 = QComboBox()
        self._projection_types_2.addItems(proj_type_options)
        self._projection_types_2.setCurrentText("Raw")

        self._projection_types_3 = QComboBox()
        self._projection_types_3.addItems(proj_type_options)
        self._projection_types_3.setCurrentText("Average Intensity")

        # Slices
        self._slices_1 = QLineEdit()
        self._slices_2 = QLineEdit()
        self._slices_3 = QLineEdit()

        # Run buttons
        self._btn_create_z_projections = QPushButton('Show Z-Projections')
        # self._btn_create_z_projections.setEnabled(False)
        self._btn_merge_stacks = QPushButton("Project && Merge Stacks")
        #self._btn_merge_stacks.setEnabled(False)

        # Slider
        self.sld = QLabeledDoubleRangeSlider(Qt.Orientation.Horizontal)# QSlider(Qt.Orientation.Horizontal)
        self.sld.setTickPosition(3)
        
        ### Set layout ##
        self._set_grid_layout()     

        # Connect to own callbacks or changes
        # Connect the viewer layer change event to update the combo box
        self.viewer.layers.events.inserted.connect(self._update_input_options)
        self.viewer.layers.events.removed.connect(self._update_input_options)

        # Connect the QLineEdit text change to a handler method
        self._slices_1.textChanged.connect(self.on_text_change)
        self._slices_2.textChanged.connect(self.on_text_change)
        self._slices_3.textChanged.connect(self.on_text_change)

        self._btn_create_z_projections.clicked.connect(self._show_z_projections)  
        self._btn_merge_stacks.clicked.connect(self._project_then_merge_stacks) 
        
        # Slider
        self.sld.rangeChanged.connect(lambda *a: print(f"new range: {a}"))


    def on_text_change(self):
        slices_all = [self._slices_1, self._slices_2, self._slices_3]
        for stack in range(3):
            entered_text = slices_all[stack].text()
            slices_all[stack].setText(entered_text)


    # def _enable_zprojection(self):
    #     """Disable or enable Z-Projection button"""
    #     slice_input_all = [self._slices_1, self._slices_2, self._slices_3]
    #     for stack in range(3):
    #         if self._is_slice_input_valid(slice_input_all[stack]) is True:
    #             self._btn_create_z_projections.setEnabled(True)
    #         else:
    #             show_info("Slice input is not valid for Stack {}." .format(str(stack)))


    def _update_input_options(self):
        """Update the combo box with the current image layers."""
        self._input_layer.clear()
        # image_layers = [layer.name for layer in self.viewer.layers if isinstance(layer, napari.layers.Image)]
        # self._input_layer.addItems(image_layers)

        for layer in self.viewer.layers:
            if isinstance(layer, napari.layers.Image):
                self._input_layer.addItem(layer.name, layer)


    def _set_grid_layout(self):
        """Create layout"""
        # Create layout and define default settings
        grid_layout = QGridLayout()

        # Add input
        grid_layout.addWidget(QLabel("<b>Input</b>"), 0, 0)
        grid_layout.addWidget(self._input_layer, 0, 1, 1, 3)

        # # Create 1. column, stack and color names
        grid_layout.addWidget(QLabel(""), 1, 0)
        grid_layout.addWidget(QLabel("<b>Stack 1 (R)</b>"), 2, 0)
        grid_layout.addWidget(QLabel("<b>Stack 2 (G)</b>"), 3, 0)
        grid_layout.addWidget(QLabel("<b>Stack 3 (B)</b>"), 4, 0)

        # # Create 2. column "Shift by"
        grid_layout.addWidget(QLabel("<b>Shift by</b>"), 1, 1)
        grid_layout.addWidget(self._shift_1, 2, 1)
        grid_layout.addWidget(self._shift_2, 3, 1)
        grid_layout.addWidget(self._shift_3, 4, 1)

        # Create 3. column "Projection Type"
        grid_layout.addWidget(QLabel("<b>Projection Type</b>"), 1, 2)
        grid_layout.addWidget(self._projection_types_1, 2, 2)
        grid_layout.addWidget(self._projection_types_2, 3, 2)
        grid_layout.addWidget(self._projection_types_3, 4, 2)

        # # Create 4. column "Slices"
        grid_layout.addWidget(QLabel("<b>Slices</b>"), 1, 3)
        grid_layout.addWidget(self._slices_1, 2, 3)
        grid_layout.addWidget(self._slices_2, 3, 3)
        grid_layout.addWidget(self._slices_3, 4, 3)

        # Create Z-Projection button
        grid_layout.addWidget(self._btn_create_z_projections, 5, 1, 1, 3)

        # Create Composite button
        grid_layout.addWidget(self._btn_merge_stacks, 6, 1, 1, 3)

        ## Slider test
        # grid_layout.addWidget(self.sld, 7, 1, 1, 3)
        
        # Putting everything together
        grid_layout.setAlignment(Qt.AlignTop)
        self.setLayout(grid_layout)
        return


    def _compute_z_projection(self):
        """Computes z-projections for all 3 stacks; output is None for stacks where slice input is invalid"""
        # TODO: check that input is valid; if slice number > z
        image_layer = self._input_layer.currentData()
        image = image_layer.data # img_as_float(image_layer.data)
        
        if image_layer is None:
            show_info("No input image.") 
            return None
        if len(image.shape) != 4:
            show_info("Image must be 4D with dimensions TZYX")
            return None

        proj_types_all = [self._projection_types_1, self._projection_types_2, self._projection_types_3]
        slice_input_all = [self._slices_1.text(), self._slices_2.text(), self._slices_3.text()]
        outputs = []

        for stack in range(3):    
            if proj_types_all[stack].currentText() == "Raw":
                img_projected = self._input_layer.currentData().data
            elif self._is_slice_input_valid(slice_input_all[stack]) is False:
                img_projected = None
            else:
                if proj_types_all[stack].currentText() == "Average Intensity":
                    img_projected = self._average_intensity(slice_input_all[stack])
                elif proj_types_all[stack].currentText() == "Min Intensity":
                    img_projected = self._min_intensity(slice_input_all[stack])
                elif proj_types_all[stack].currentText() == "Max Intensity":
                    img_projected = self._max_intensity(slice_input_all[stack])
                # elif Projection_Type == "Sum Slices":
                #     output = _sum_slices(Input, Slices)
                # elif Projection_Type == "Standard Deviation":
                #     output = _standard_deviation(Input, Slices)
                elif proj_types_all[stack].currentText() == "Median":
                    img_projected = self._median_intensity(slice_input_all[stack])
                else:
                    img_projected = None
            outputs.append(img_projected)
                       
        return outputs
    

    def _show_z_projections(self):
        """Add projected images as image layers to viewer"""
        image_layer = self._input_layer.currentData()
        img_projected = self._compute_z_projection()
        
        for stack, img in enumerate(img_projected):
            name = image_layer.name + "_zproj_stack" + str(stack+1)
            self.viewer.add_image(img, name=name) 

        # # TODO: check that input is valid; if slice number > z
        # image_layer = self._input_layer.currentData()
        # image = image_layer.data # img_as_float(image_layer.data)
        
        # if image_layer is None:
        #     return 
        # if len(image.shape) != 4:
        #     show_info("Image must be 4D with dimensions TZYX")
        #     return

        # proj_types_all = [self._projection_types_1, self._projection_types_2, self._projection_types_3]
        # slice_input_all = [self._slices_1.text(), self._slices_2.text(), self._slices_3.text()]

        # for stack in range(3):    
        #     if proj_types_all[stack].currentText() == "Raw":
        #         output = self._input_layer.currentData().data
        #         name = image_layer.name + "_zprojection_stack" + str(stack+1)
        #         # output = (output * 255 / np.max(output)).astype('uint8')
        #         self.viewer.add_image(output, name=name) 
            
        #     elif self._is_slice_input_valid(slice_input_all[stack]) is False:
        #         show_info("Slice input is not valid for stack {}." .format(str(stack+1)))
        #     else:
        #         if proj_types_all[stack].currentText() == "Average Intensity":
        #             output = self._average_intensity(slice_input_all[stack])
        #         elif proj_types_all[stack].currentText() == 'Min Intensity':
        #             output = self._min_intensity(slice_input_all[stack])
        #         elif proj_types_all[stack].currentText() == 'Max Intensity':
        #             output = self._max_intensity(slice_input_all[stack])
        #         # elif Projection_Type == 'Sum Slices':
        #         #     output = _sum_slices(Input, Slices)
        #         # elif Projection_Type == 'Standard Deviastion':
        #         #     output = _standard_deviation(Input, Slices)
        #         elif proj_types_all[stack].currentText() == 'Median':
        #             output = self._median_intensity(slice_input_all[stack])
        #         else:
        #             show_info("Projection type not valid for stack {}." .format(str(stack+1)))
        #             return

        #         name = image_layer.name + "_zproj_stack" + str(stack+1)
        #         # output = (output * 255 / np.max(output)).astype('uint8')
        #         self.viewer.add_image(output, name=name) 
                       
        # return
    

    # def _concat_slices(self, slice_numbers):
    #     """
    #     Given image input has dimensions TZYX and slice_numbers as string e.g. "1, 2, 5:10:2"
    #     Returns concatenated slices TNYX with N being the number of slices the user inputs
    #     """
    #     image_input = self._input_layer.currentData().data

    #     # Get image dimensions
    #     t, z, y, x = image_input.shape
        
    #     slice_num = slice_numbers.replace(" ", "") # remove all whitespace
    #     slice_num_parts = slice_num.split(sep=',') # separate by commas

    #     indices = []
    #     for substring in slice_num_parts:
    #         if ":" in substring:
    #             parts = list(map(int, substring.split(':')))
    #             idx = slice(*parts)
    #         else:
    #             idx = int(substring)
    #         indices.append(idx)

    #     slices = [image_input[:, idx].reshape(t, -1, y, x) for idx in indices]
    #     slices_concat = np.concatenate(slices, axis=1)
    #     return slices_concat


    def _average_intensity(self, slice_num):
        """
        Given that input has dimensions TZYX, averages stack of slice_num planes along Z-axis
        Outputs image of dimension TZYX
        """
        image_input = self._input_layer.currentData().data
        slice_num = int(slice_num)
        t, z, y, x = image_input.shape # Image dimensions
        
        image_projected = np.zeros(image_input.shape)

        for i in range(z):
            if i - slice_num < 0:
                image_projected[:, i] = np.mean(image_input[:, 0:i+slice_num], axis=1)
            elif i + slice_num >= z:
                image_projected[:, i] = np.mean(image_input[:, i:z], axis=1)
            else:
                image_projected[:, i] = np.mean(image_input[:, i-slice_num:i+slice_num], axis=1)

        return image_projected
        

    def _max_intensity(self, slice_num):
        """
        Given that input has dimensions TZYX, compute max intensity projection along Z-axis
        Outputs image of dimension TYX
        Max intensity projection of stack
        """       
        image_input = self._input_layer.currentData().data
        slice_num = int(slice_num)
        t, z, y, x = image_input.shape # Image dimensions
        image_projected = np.zeros(image_input.shape)

        for i in range(z):
            if i - slice_num < 0:
                image_projected[:, i] = np.max(image_input[:, 0:i+slice_num], axis=1)
            elif i + slice_num >= z:
                image_projected[:, i] = np.max(image_input[:, i:z], axis=1)
            else:
                image_projected[:, i] = np.max(image_input[:, i-slice_num:i+slice_num], axis=1)

        return image_projected
    

    def _min_intensity(self, slice_num):
        """
        Given that input has dimensions TZYX, compute min intensity projection along Z-axis
        Outputs image of dimension TYX
        """
        image_input = self._input_layer.currentData().data
        slice_num = int(slice_num)
        t, z, y, x = image_input.shape # Image dimensions
        image_projected = np.zeros(image_input.shape)

        for i in range(z):
            if i - slice_num < 0:
                image_projected[:, i] = np.min(image_input[:, 0:i+slice_num], axis=1)
            elif i + slice_num >= z:
                image_projected[:, i] = np.min(image_input[:, i:z], axis=1)
            else:
                image_projected[:, i] = np.min(image_input[:, i-slice_num:i+slice_num], axis=1)

        return image_projected
    

    def _median_intensity(self, slice_num):
        """
        Given that input has dimensions TZYX, compute median intensity projection along Z-axis
        Outputs image of dimension TYX
        """
        image_input = self._input_layer.currentData().data
        slice_num = int(slice_num)
        t, z, y, x = image_input.shape # Image dimensions
        image_projected = np.zeros(image_input.shape)

        for i in range(z):
            if i - slice_num < 0:
                image_projected[:, i] = np.median(image_input[:, 0:i+slice_num], axis=1)
            elif i + slice_num >= z:
                image_projected[:, i] = np.median(image_input[:, i:z], axis=1)
            else:
                image_projected[:, i] = np.median(image_input[:, i-slice_num:i+slice_num], axis=1)

        return image_projected


    def _project_then_merge_stacks(self):
        # TODO: check inputs
        # TODO: possibility to merge only 2 stacks?
        images_projected = self._compute_z_projection()
        # Normalize; RGB range [0, 255]
        images_projected_normed = [(img / np.max(img) * 255).astype('uint8') for img in images_projected]         
        
        image_input = self._input_layer.currentData().data
        t, z, y, x = image_input.shape 
        result = np.zeros((t, z, y, x, 3))

        # Shifted 
        idx_shifts = [self._shift_1.text(), self._shift_2.text(), self._shift_3.text()]
        
        for stack in range(3):
            if int(idx_shifts[stack]) < 0:
                idx = -int(idx_shifts[stack])
                result[:, :z-idx, :, :, stack] = images_projected_normed[stack][:, idx:]
                result[:, z-idx:, :, :, stack] = np.zeros((t, idx, y, x))
            elif int(idx_shifts[stack]) == 0:
                result[:, :, :, :, stack] = images_projected_normed[stack]
            else:
                idx = int(idx_shifts[stack])
                result[:, :idx, :, :, stack] = np.zeros((t, idx, y, x))
                result[:, idx:, :, :, stack] = images_projected_normed[stack][:, :z-idx]

        self.viewer.add_image(result.astype("uint8")) 
        return


    def _on_click(self):
        show_info("napari has", len(self.viewer.layers), "layers")


    def _is_slice_input_valid(self, slices):
        # TODO: if slice number > z
        
        """
        1. if it contains any characters except for int numbers, ",", " " or ":" it is not a valid input
        2. if it exceeds number of planes
        3. ,, empty or completely empty
        4. input like ,:, or ::
        5. Overlapping planes
        """
        image_input = self._input_layer.currentData().data
        slice_numbers = slices # .text()

        # Image dimensions
        t, z, y, x = image_input.shape

        acceptable_chars = set("0123456789:, ")
        if set(slice_numbers).issubset(acceptable_chars) is False:
            return False
        
        # Check single substring
        slice_num = slice_numbers.replace(" ", "") # remove all whitespace
        slice_num_parts = slice_num.split(sep=',') # separate by commas
                        
        for substring in slice_num_parts:  
        #     if len(substring) not in [1, 3, 5]: #Check length of substrings
        #         return False

            # Check slice inputs, start:stop or start:stop:step
            if ":" in substring:                
                parts = substring.split(':')

                try:
                    # Convert parts to integers
                    start = int(parts[0])
                    stop = int(parts[1])
                    step = int(parts[2]) if len(parts) == 3 else 1
                    
                    # Validate values for slice
                    if start < 0 or stop < 0 or (len(parts) == 3 and step == 0):
                        return False
                    
                    if start >= stop:
                        return False
                    
                    # Check if exceeds image dimension in z-plane
                    if start >= z or stop > z:
                        return False

                except ValueError:
                    # If conversion to int fails
                    return False
            else:
                try:
                    # Convert index to integer
                    index = int(substring)
                    if index < 0 or index >= z:
                        return False
                except ValueError:
                    # If conversion to int fails
                    return False

        return True


# class ExampleQWidget(QWidget):
#     # your QWidget.__init__ can optionally request the napari viewer instance
#     # use a type annotation of 'napari.viewer.Viewer' for any parameter
#     def __init__(self, viewer: "napari.viewer.Viewer"):
#         super().__init__()
#         self.viewer = viewer

#         btn = QPushButton("Click me!")
#         btn.clicked.connect(self._on_click)

#         self.setLayout(QHBoxLayout())
#         self.layout().addWidget(btn)

#     def _on_click(self):
#         print("napari has", len(self.viewer.layers), "layers")
